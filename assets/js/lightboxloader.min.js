(() => {
  "use strict";
  class t {
    constructor() {
      var e;
      (e = "listenerMap") in this
        ? Object.defineProperty(this, e, {
            value: null,
            enumerable: !0,
            configurable: !0,
            writable: !0,
          })
        : (this[e] = null),
        (this.listenerMap = new Map());
    }
    on(t, e, s) {
      let i = 3 < arguments.length && void 0 !== arguments[3] && arguments[3];
      const n = "string" == typeof t ? [t] : t;
      let r = this.listenerMap.get(e);
      r || ((r = {}), this.listenerMap.set(e, r)),
        n.forEach((t) => {
          (r[t] = r[t] || []),
            -1 === r[t].indexOf(s) && r[t].push(s),
            e.addEventListener(t, s, i);
        });
    }
    off(t, e, s) {
      const i = "string" == typeof t ? [t] : t;
      let n = 3 < arguments.length && void 0 !== arguments[3] && arguments[3];
      "boolean" == typeof s && (n = s);
      const r = this.listenerMap.get(e) || {};
      i.forEach((t) => {
        "function" == typeof s
          ? e.removeEventListener(t, s, n)
          : (r[t] || []).forEach((s) => {
              e.removeEventListener(t, s, n);
            });
      });
    }
    unbindAll() {
      this.listenerMap.forEach((t, e) => {
        (t = Object.keys(t)), this.off(t, e, !0), this.off(t, e, !1);
      });
    }
    destroy() {
      this.unbindAll(), delete this.listenerMap;
    }
  }
  class e {
    constructor() {
      var t =
        0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : {};
      (this.events = t), (this.hop = t.hasOwnProperty);
    }
    on(t, e) {
      Array.isArray(t) && t.forEach((t) => this.on(t, e)),
        this.hop.call(this.events, t) || (this.events[t] = []);
      const s = this.events[t].push(e) - 1;
      return {
        remove() {
          delete this.events[t][s];
        },
      };
    }
    emit(t, e) {
      Array.isArray(t)
        ? t.forEach((t) => this.emit(t, e))
        : this.hop.call(this.events, t) &&
          this.events[t].forEach((t) => t(e || {}));
    }
  }
  const s_START = "touchstart",
    s_END = "touchend",
    s_MOVE = "touchmove",
    s_CANCEL = "touchcancel",
    i_CLICK = "click",
    i_MOVE = "mousemove",
    i_UP = "mouseup",
    i_DOWN = "mousedown",
    i_LEAVE = "mouseleave",
    n = {
      TAB: 9,
      ENTER: 13,
      ESCAPE: 27,
      SPACE: 32,
      END: 35,
      HOME: 36,
      LEFT: 37,
      UP: 38,
      RIGHT: 39,
      DOWN: 40,
    },
    r_TAB = "Tab",
    o = n,
    d = [
      "button",
      'input:not([type="hidden"])',
      "select",
      "textarea",
      "a[href]",
      '[contenteditable]:not([contenteditable="false"])',
      '[tabindex]:not([tabindex=""])',
      "iframe",
    ].join(","),
    h = (t) => t.matches(d) || t === document.body,
    c = (t) =>
      ((t) => {
        var {
            display: e,
            visibility: s,
            position: i,
          } = window.getComputedStyle(t),
          n = "fixed" === i,
          i = [document.documentElement, document.body].includes(t);
        return (
          (null !== t.offsetParent || i || n) && "none" !== e && "hidden" !== s
        );
      })(t) &&
      !((t) =>
        t.hasAttribute("disabled") || null !== t.closest("fieldset[disabled]"))(
        t
      ),
    u = function () {
      let t =
        0 < arguments.length && void 0 !== arguments[0]
          ? arguments[0]
          : document.body;
      var { includeContainer: e = !1 } =
        1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : {};
      const s = Array.from(t.querySelectorAll(d));
      return e && h(t) && s.unshift(t), s;
    },
    m = function (t) {
      var e = (s = t instanceof HTMLElement) ? t : document.body,
        s =
          (s
            ? 1 < arguments.length && void 0 !== arguments[1]
              ? arguments[1]
              : {}
            : t) || {};
      const i = u(e, { includeContainer: !1, ...s });
      return i.filter(c);
    };
  m.functionName = "getFocusableElements";
  const f = m,
    v = (t) =>
      0 <=
      ((t) => {
        var e = parseInt(t.getAttribute("tabindex"), 10);
        return Number.isNaN(e) ? (t.isContentEditable ? 0 : t.tabIndex) : e;
      })(t),
    p = function (t) {
      let e = (
        1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : {}
      ).container;
      var s = document.getElementById(t);
      return e instanceof Element && !e.contains(s) ? null : s;
    },
    E = function (t) {
      var e = (
        1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : {}
      ).container;
      const s = e instanceof Element ? e : document.documentElement;
      return s.querySelector(t);
    },
    b = function (t) {
      var e = (
        1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : {}
      ).container;
      return p(t, { container: e }) || E(t, { container: e });
    },
    y = function (t) {
      var { container: e, strict: s = !1 } =
        1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : {};
      const i = e instanceof Element ? e : document.documentElement;
      let n = null;
      if (
        (t instanceof Element
          ? (n = i.contains(t) ? t : null)
          : "string" == typeof t && (n = b(t, { container: i })),
        s && !n)
      )
        throw new Error("[getElement]: No element found.");
      return n;
    };
  function T(t, e, s) {
    (function (t, e) {
      if (e.has(t))
        throw new TypeError(
          "Cannot initialize the same private elements twice on an object"
        );
    })(t, e),
      e.set(t, s);
  }
  function w(t, e, s) {
    return (
      (function (t, e, s) {
        if (e.set) e.set.call(t, s);
        else {
          if (!e.writable)
            throw new TypeError("attempted to set read only private field");
          e.value = s;
        }
      })(t, O(t, e, "set"), s),
      s
    );
  }
  function D(t, e) {
    return (function (t, e) {
      return e.get ? e.get.call(t) : e.value;
    })(t, O(t, e, "get"));
  }
  function O(t, e, s) {
    if (!e.has(t))
      throw new TypeError(
        "attempted to " + s + " private field on non-instance"
      );
    return e.get(t);
  }
  var S = new WeakMap(),
    A = new WeakMap(),
    I = new WeakMap(),
    R = new WeakMap(),
    x = new WeakMap(),
    P = new WeakMap(),
    M = new WeakMap(),
    C = new WeakMap(),
    L = new WeakMap(),
    H = new WeakMap();
  function k() {
    return (
      D(this, A) && null !== D(this, S) && document.body.contains(D(this, S))
    );
  }
  function N() {
    return D(this, R)[0] || D(this, S);
  }
  function U() {
    return D(this, x)[0] || D(this, S);
  }
  function V() {
    var t = D(this, x).length;
    return t ? D(this, x)[t - 1] : D(this, S);
  }
  const j = "-open",
    F = "-closing",
    B = class {
      constructor(s) {
        (this.id = s),
          (this.triggerId = `[data-cl-modal="${this.id}"]`),
          (this.modal = document.getElementById(s)),
          (this.tabTrap = new (class {
            get isSet() {
              return D(this, A);
            }
            get tabbableElements() {
              return D(this, x);
            }
            constructor(t) {
              T(this, C, { get: V, set: void 0 }),
                T(this, M, { get: U, set: void 0 }),
                T(this, P, { get: N, set: void 0 }),
                T(this, I, { get: k, set: void 0 }),
                T(this, S, { writable: !0, value: null }),
                T(this, A, { writable: !0, value: !1 }),
                T(this, R, { writable: !0, value: [] }),
                T(this, x, { writable: !0, value: [] }),
                T(this, L, {
                  writable: !0,
                  value: (t) => {
                    D(this, I) && t.key === r_TAB && D(this, H).call(this, t);
                  },
                }),
                T(this, H, {
                  writable: !0,
                  value: (t) =>
                    t.shiftKey || t.target !== D(this, C)
                      ? t.shiftKey &&
                        [D(this, P), D(this, M)].includes(t.target)
                        ? (t.preventDefault(), void D(this, C).focus())
                        : void (
                            D(this, S).contains(t.target) || D(this, M).focus()
                          )
                      : (t.preventDefault(), void D(this, M).focus()),
                }),
                (t = y(t, { strict: !0 })),
                w(this, S, t),
                this.update(),
                document.addEventListener("keydown", D(this, L));
            }
            update() {
              w(this, R, f(D(this, S), { includeContainer: !0 })),
                w(this, x, D(this, R).filter(v));
            }
            set() {
              var t = (
                0 < arguments.length && void 0 !== arguments[0]
                  ? arguments[0]
                  : { focus: !0 }
              ).focus;
              this.update(), w(this, A, !0), t && this.focus();
            }
            focus() {
              !D(this, S).contains(document.activeElement) &&
                D(this, P) &&
                D(this, P).focus();
            }
            unset() {
              w(this, A, !1);
            }
            destroy() {
              w(this, A, !1),
                w(this, S, null),
                w(this, R, []),
                w(this, x, []),
                document.removeEventListener("keydown", D(this, L));
            }
          })(this.modal)),
          (this.isOpen = !1),
          (this.binder = new t()),
          (this.eventHandler = new e());
      }
      mount() {
        try {
          this.determineExitIntent(),
            this.bindCloseHandlers(),
            this.bindOpenHandlers(),
            this.bindKeys();
        } catch (t) {
          console.error("[cl-modal]: " + t);
        }
        return this;
      }
      open(t) {
        return (
          this.isOpen ||
            ((document.body.style.overflow = "hidden"),
            this.modal.setAttribute("aria-hidden", "false"),
            this.modal.classList.remove(F),
            this.modal.classList.add(j),
            this.tabTrap.set(),
            (this.isOpen = !0),
            (this.triggerElement = t),
            this.eventHandler.emit("open", { element: t })),
          this
        );
      }
      close() {
        return (
          this.isOpen &&
            ((document.body.style.overflow = ""),
            this.modal.classList.remove(j),
            this.modal.classList.add(F),
            this.modal.setAttribute("aria-hidden", "true"),
            (this.isOpen = !1),
            this.tabTrap.unset(),
            this.reloadIFrames(),
            this.eventHandler.emit("close"),
            this.triggerElement && this.triggerElement.focus(),
            this.exitIntent && (this.dismissed = !0)),
          this
        );
      }
      reloadIFrames() {
        this.modal.querySelectorAll("iframe").forEach((t) => {
          var e = t.getAttribute("src");
          e && t.setAttribute("src", e);
        });
      }
      determineExitIntent() {
        (!this.modal && this.modal.hasAttribute("data-cl-exit")) ||
          (this.exitIntent = Boolean(this.modal.dataset.clExit));
      }
      on(t, e) {
        return this.eventHandler.on(t, e), this;
      }
      bindOpenHandlers() {
        const t = document.querySelectorAll(this.triggerId),
          e = (t) => this.open(t.currentTarget);
        return (
          t.forEach((t) => {
            this.binder.on("click", t, e);
          }),
          this.exitIntent &&
            this.binder.on("mouseout", document, (t) => {
              t.toElement || t.relatedTarget || this.dismissed || this.open();
            }),
          this
        );
      }
      bindCloseHandlers() {
        return (
          document.querySelectorAll('[data-cl-modal="close"]').forEach((t) => {
            this.binder.on("click", t, (t) => {
              "close" === t.target.getAttribute("data-cl-modal") &&
                this.close();
            });
          }),
          this
        );
      }
      bindKeys() {
        return (
          this.binder.on("keyup", document, (t) => {
            t.keyCode === o.ESCAPE && this.close();
          }),
          this
        );
      }
      destroy() {
        return this.binder.destroy(), this.tabTrap.destroy(), this;
      }
    },
    z = "[cl-carousel]",
    G = {
      MOUNTED: z + " mounted",
      DESTROY: z + " destroy",
      UPDATE: z + " update",
      MOVE: z + " move",
      MOVED: z + " moved",
      JUMP: z + " jump",
      RESIZE: z + " resize",
      BUILDING: z + " building",
      BUILT: z + " built",
      RUN: z + " run",
      DEACTIVATE: z + " deactivate",
    },
    Y = (t) => console.error(z + " " + t),
    q = (t, e) => {
      const s = { ...t, ...e };
      return (
        Object.prototype.hasOwnProperty.call(e, "classes") &&
          (s.classes.type = { ...t.classes.type, ...e.classes.type }),
        s
      );
    },
    $ = {
      infinite: !0,
      startAt: 0,
      focusAt: 0,
      slidesPerView: 3,
      slidesToScroll: 1,
      slideGap: 24,
      dotGap: 8,
      peek: 48,
      easing: "ease",
      animationDuration: 300,
      swipeThreshold: 80,
      dragThreshold: 80,
      touchRatio: 0.5,
      touchAngle: 45,
      classes: {
        touch: "-touch",
        dragging: "-dragging",
        inactive: "-inactive",
        slide: { active: "-active", clone: "-clone" },
        nav: { active: "-active" },
      },
      breakpoints: [
        {
          order: 1,
          mediaQuery: "max-width: 599px",
          settings: { slidesPerView: 1, slidesToScroll: 1, peek: 24 },
        },
        {
          order: 2,
          mediaQuery: "min-width: 600px",
          settings: { slidesPerView: 2, slidesToScroll: 2, peek: 32 },
        },
        { order: 4, mediaQuery: "min-width: 1080px", settings: {} },
      ],
    },
    K = (t) => t && t instanceof window.HTMLElement,
    _ = '[data-cl-carousel="rail"]',
    X = (t, e, s) => {
      var i = Math.floor(s / e.Sizes.slideWidth);
      return s + e.Gaps.value * i;
    },
    Z = (t, e, s) => s + e.Clones.grow / 2,
    Q = (t, e, s) =>
      0 <= t.settings.focusAt
        ? s - ("object" == typeof (e = e.Peek.value) ? e.before : e)
        : s,
    J = (t, e, s) => {
      var i = e.Gaps.value,
        { width: n, slideWidth: e } = e.Sizes;
      return "center" === (t = t.settings.focusAt)
        ? s - (n / 2 - e / 2)
        : s - e * t - i * t;
    };
  var tt = void 0;
  function et(t) {
    let e =
        1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 100,
      s = Date.now();
    return function () {
      if (s + e - Date.now() < 0) {
        for (var i = arguments.length, n = new Array(i), r = 0; r < i; r++)
          n[r] = arguments[r];
        t.apply(tt, n), (s = Date.now());
      }
    };
  }
  const st = () => {
      let t = !1;
      try {
        var e = {
          get passive() {
            return !(t = { passive: !0 });
          },
        };
        window.addEventListener("test", null, e),
          window.removeEventListener("test", null, e);
      } catch (e) {
        console.error("Passive event error: " + e), (t = !1);
      }
      return t;
    },
    it = "data-cl-carousel",
    nt = `[${it}*="<"]`,
    rt = `[${it}*=">"]`,
    ot = (t, e, s) => Math.max(e, Math.min(t, s)),
    at = [s_MOVE, i_MOVE],
    lt = [s_END, s_CANCEL, i_UP, i_LEAVE],
    dt = [i_DOWN, i_MOVE, i_UP, i_LEAVE],
    ht = {
      Html: (t, e, s) => {
        const i = {
          mount() {
            const e = t.settings.classes.slide.clone;
            (this.ROOT = t.selector),
              (this.TRACK = this.root.querySelector(_)),
              (this.slides = [...this.train.children].filter(
                (t) => !t.classList.contains(e)
              )),
              this.slides.forEach((t) => {
                t.tabIndex = 0;
              });
          },
          activate() {
            this.root.classList.remove(t.settings.classes.inactive);
          },
          deactivate() {
            this.root.classList.add(t.settings.classes.inactive);
          },
          checkSlideCount() {
            this.slides.length <= t.settings.slidesPerView && t.active
              ? t.deactivate()
              : t.active || t.activate();
          },
        };
        return (
          Object.defineProperty(i, "ROOT", {
            get: () => i.root,
            set(t) {
              (t = y(t)), K(t) ? (i.root = t) : Y("root element not found");
            },
          }),
          Object.defineProperty(i, "TRACK", {
            get: () => i.TRACK,
            set(t) {
              K(t)
                ? (i.track = t)
                : Y(`track element not found - use ${_} attribute.`);
            },
          }),
          Object.defineProperty(i, "train", {
            get: () => (i.track ? i.track.children[0] : { children: [] }),
          }),
          s.on([G.BUILDING, G.RESIZE], () => i.checkSlideCount()),
          s.on(G.UPDATE, () => i.activate()),
          s.on(G.DEACTIVATE, () => i.deactivate()),
          i
        );
      },
      Translate: (t, e, s) => {
        const i = {
          set(s) {
            (s = ((t, e) => {
              const s = [X, Z, Q, J];
              return {
                mutate(i) {
                  try {
                    s.forEach((s) => {
                      i = s(t, e, i);
                    });
                  } catch (t) {
                    Y("transformer error: " + t);
                  }
                  return i;
                },
              };
            })(t, e).mutate(s)),
              (e.Html.train.style.transform = `translate3d(${
                -1 * s
              }px, 0px, 0px)`);
          },
          remove() {
            e.Html.train.style.transform = "";
          },
          getStartIndex() {
            var s = e.Sizes.length,
              { index: i, settings: n } = t;
            return e.Run.isOffset(">")
              ? s + (i - n.slidesPerView)
              : (i + n.slidesPerView) % s;
          },
          getTravelDistance() {
            var s = e.Sizes.slideWidth * t.settings.slidesPerView;
            return e.Run.isOffset(">") ? -s : s;
          },
        };
        return (
          s.on(G.MOVE, (n) =>
            t.active
              ? t.isInfinite() && e.Run.isOffset()
                ? (e.Transition.after(() => {
                    s.emit(G.JUMP), i.set(e.Sizes.slideWidth * t.index);
                  }),
                  (n = e.Sizes.slideWidth * e.Translate.getStartIndex()),
                  i.set(n - e.Translate.getTravelDistance()))
                : i.set(n.movement)
              : i.remove()
          ),
          s.on([G.DESTROY, G.DEACTIVATE], () => i.remove()),
          i
        );
      },
      Transition: (t, e, s) => {
        let i = !1;
        const n = {
          compose(e) {
            var s = t.settings;
            return e + ` ${i ? 0 : this.duration}ms ` + s.easing;
          },
          set() {
            t.active &&
              (e.Html.train.style.transition = this.compose(
                0 < arguments.length && void 0 !== arguments[0]
                  ? arguments[0]
                  : "transform"
              ));
          },
          remove() {
            e.Html.train.style.transition = "";
          },
          after(t) {
            setTimeout(() => t(), this.duration + 50);
          },
          enable() {
            (i = !1), this.set();
          },
          disable() {
            (i = !0), this.set();
          },
        };
        return (
          Object.defineProperty(n, "duration", {
            get: () => t.settings.animationDuration,
          }),
          s.on([G.BUILDING, G.RESIZE, G.JUMP], () => n.disable()),
          s.on(G.MOVE, () => n.set()),
          s.on(G.RUN, () => n.enable()),
          s.on([G.DESTROY, G.DEACTIVATE], () => n.remove()),
          n
        );
      },
      Dots: (e, s, i) => {
        const n = new t(),
          r = {
            mount() {
              (this.dots = []),
                (this.index = 0),
                (this.pageOffset = 0),
                (this.centerOffset = 0),
                (this.threshold = e.isInfinite() ? 4 : 5),
                (this.dotScales = [1, 0.75, 0.5, 0.25]),
                (this.container = s.Html.root.querySelector(
                  '[data-cl-carousel="dots"]'
                )),
                this.mountDots();
            },
            mountDots() {
              var t = e.settings,
                i = s.Sizes.length;
              !this.container ||
                i <= t.slidesPerView ||
                ((this.totalDots = this.getNumberOfDots()),
                (this.useFancyDots = this.totalDots > this.threshold),
                this.useFancyDots
                  ? ((this.maxDots = ot(this.totalDots, 5, 7)),
                    (this.centerDots = 3),
                    e.isInfinite() &&
                      6 === this.totalDots &&
                      (this.dotScales[2] = 0))
                  : ((this.maxDots = this.totalDots),
                    (this.centerDots = this.totalDots)),
                this.clearDots(),
                this.renderDots(),
                this.setContainerSize(),
                t.infinite && this.useFancyDots
                  ? this.animateDotsInfinite()
                  : this.animateDots());
            },
            clearDots() {
              this.container &&
                ((this.container.textContent = ""),
                (this.container.style.transition = ""),
                (this.container.style.transform = ""));
            },
            renderDots() {
              var t = e.settings,
                s = t.infinite && this.useFancyDots ? 10 : this.totalDots;
              this.container.classList.add("cl-carousel-dot-" + this.totalDots);
              for (let t = 0; t < s; t++) {
                var i = document.createElement("li");
                this.container.appendChild(i);
              }
              (this.dots = [...this.container.children]),
                (this.dotWidth =
                  (null === (t = this.dots[0]) || void 0 === t
                    ? void 0
                    : t.offsetWidth) + e.settings.dotGap);
            },
            getNumberOfDots() {
              var { slidesToScroll: t, slidesPerView: i } = e.settings,
                n = s.Sizes.length,
                r = 1 === t,
                o = i !== t;
              let a = Math.ceil((n - (i - t)) / t);
              return e.isInfinite() && (r ? (a = n) : o && a++), a;
            },
            getActiveDot() {
              var { index: t, settings: s } = e,
                i = t % s.slidesToScroll != 0;
              let n = Math.floor(t / s.slidesToScroll);
              return i && !e.isInfinite() && (n += 1), n;
            },
            setContainerSize() {
              this.container.style.width = this.dotWidth * this.maxDots + "px";
            },
            setDotSizes(t) {
              let s =
                1 < arguments.length && void 0 !== arguments[1] && arguments[1];
              const i = e.settings.classes.nav.active,
                n = Math.floor(this.centerDots / 2 + this.pageOffset);
              this.dots.forEach((e, r) => {
                var o = Math.abs(r - n);
                r === t ? e.classList.add(i) : e.classList.remove(i),
                  o > Math.floor(this.maxDots / 2)
                    ? this.transform(e, "scale(0)", s)
                    : ((o -= this.centerDots / 2),
                      (o = Math.ceil(ot(o, 0, 3))),
                      this.transform(e, `scale(${this.dotScales[o]})`, s));
              });
            },
            async transform(t, s) {
              var { animationDuration: i, easing: n } = e.settings;
              const r =
                2 < arguments.length && void 0 !== arguments[2] && arguments[2]
                  ? 0
                  : i;
              return (
                (t.style.transform = s),
                (t.style.transition = `transform ${r}ms ` + n),
                new Promise((t) => setTimeout(() => t(), r + 50))
              );
            },
            async animateDotsInfinite() {
              ">" === s.Run.direction
                ? (this.index += 1)
                : "<" === s.Run.direction && --this.index,
                await this.animateDots(this.index),
                (this.index = ot(this.index, 3, 5)),
                (this.pageOffset = 3),
                this.animateDots(this.index, !0);
            },
            async animateDots() {
              var t =
                  0 < arguments.length && void 0 !== arguments[0]
                    ? arguments[0]
                    : this.getActiveDot(),
                e =
                  1 < arguments.length &&
                  void 0 !== arguments[1] &&
                  arguments[1],
                s = t - this.pageOffset,
                i = (this.maxDots - this.centerDots) / 2;
              0 <= s && s < this.centerDots
                ? (this.centerOffset = s)
                : (this.pageOffset = t - this.centerOffset),
                (i = -this.pageOffset * this.dotWidth + i * this.dotWidth),
                this.setDotSizes(t, e),
                await this.transform(this.container, `translateX(${i}px)`, e);
            },
          };
        return (
          Object.defineProperty(r, "maxDots", {
            get() {
              return this.MAX_DOTS;
            },
            set() {
              var t =
                0 < arguments.length && void 0 !== arguments[0]
                  ? arguments[0]
                  : 7;
              (this.MAX_DOTS = t), (this.MAX_DOTS = t % 2 != 0 ? t : t + 1);
            },
          }),
          Object.defineProperty(r, "centerDots", {
            get() {
              return this.CENTER_DOTS;
            },
            set() {
              var t =
                0 < arguments.length && void 0 !== arguments[0]
                  ? arguments[0]
                  : 3;
              this.CENTER_DOTS = t % 2 != 0 ? t : t + 1;
            },
          }),
          i.on(G.RUN, () => {
            r.container &&
              (e.settings.infinite && r.totalDots > r.threshold
                ? r.animateDotsInfinite()
                : r.animateDots());
          }),
          i.on([G.MOUNTED, G.UPDATE, G.RESIZE], () => r.mountDots()),
          i.on(G.DESTROY, () => {
            n.destroy(), r.clearDots();
          }),
          r
        );
      },
      Peek: (t, e, s) => {
        const i = {
          mount() {
            this.value = t.settings.peek;
          },
        };
        return (
          Object.defineProperty(i, "value", {
            get: () => i.VALUE,
            set(t) {
              let e = t;
              "object" == typeof e
                ? ((e.before = parseInt(t.before, 10)),
                  (e.after = parseInt(t.after, 10)))
                : (e = parseInt(e, 10)),
                (i.VALUE = e);
            },
          }),
          Object.defineProperty(i, "reducer", {
            get() {
              var e = i.value,
                s = t.settings.slidesPerView;
              return "object" == typeof e
                ? e.before / s + e.after / s
                : (2 * e) / s;
            },
          }),
          s.on([G.RESIZE, G.UPDATE], () => i.mount()),
          i
        );
      },
      Sizes: (t, e, s) => {
        const i = {
          setupSlides() {
            const t = this.slideWidth + "px";
            e.Html.slides.forEach((e) => {
              e.style.width = t;
            });
          },
          setupTrain() {
            e.Html.train.style.width = this.trainSize + "px";
          },
          remove() {
            e.Html.slides.forEach((t) => {
              t.style.width = "";
            }),
              (e.Html.train.style.width = "");
          },
        };
        return (
          Object.defineProperty(i, "length", {
            get: () => e.Html.slides.length,
          }),
          Object.defineProperty(i, "width", {
            get: () => e.Html.track.offsetWidth,
          }),
          Object.defineProperty(i, "trainSize", {
            get: () => i.slideWidth * i.length + e.Gaps.grow + e.Clones.grow,
          }),
          Object.defineProperty(i, "slideWidth", {
            get: () =>
              i.width / t.settings.slidesPerView -
              e.Peek.reducer -
              e.Gaps.reducer,
          }),
          s.on([G.BUILDING, G.RESIZE, G.UPDATE], () => {
            t.active && (i.setupSlides(), i.setupTrain());
          }),
          s.on([G.DESTROY, G.DEACTIVATE], () => i.remove()),
          i
        );
      },
      Gaps: (t, e, s) => {
        const i = {
          apply(t) {
            Array.from(t).forEach((e, s) => {
              var i = this.value / 2 + "px",
                n = t.length - 1;
              (e.style.marginLeft = 0 === s ? "" : i),
                (e.style.marginRight = s === n ? "" : i);
            });
          },
          remove(t) {
            Array.from(t).forEach((t) => {
              (t.style.marginLeft = ""), (t.style.marginRight = "");
            });
          },
        };
        return (
          Object.defineProperty(i, "value", {
            get: () => parseInt(t.settings.slideGap, 10),
          }),
          Object.defineProperty(i, "grow", {
            get: () => i.value * e.Sizes.length,
          }),
          Object.defineProperty(i, "reducer", {
            get() {
              var e = t.settings.slidesPerView;
              return (i.value * (e - 1)) / e;
            },
          }),
          s.on([G.BUILT, G.UPDATE], () => {
            t.active && i.apply(e.Html.train.children);
          }),
          s.on([G.DESTROY, G.DEACTIVATE], () => {
            i.remove(e.Html.train.children);
          }),
          i
        );
      },
      Move: (t, e, s) => {
        const i = {
          mount() {
            this.OFFSET = 0;
          },
          make() {
            (this.offset =
              0 < arguments.length && void 0 !== arguments[0]
                ? arguments[0]
                : 0),
              s.emit(G.MOVE, { movement: this.value }),
              e.Transition.after(() => {
                s.emit(G.MOVED, { movement: this.value });
              });
          },
        };
        return (
          Object.defineProperty(i, "offset", {
            get: () => i.OFFSET,
            set(t) {
              i.OFFSET = t ? parseInt(t, 10) : 0;
            },
          }),
          Object.defineProperty(i, "translate", {
            get: () => e.Sizes.slideWidth * t.index,
          }),
          Object.defineProperty(i, "value", {
            get() {
              var { offset: t, translate: e } = this;
              return e - t;
            },
          }),
          s.on([G.BUILDING, G.RUN], () => i.make()),
          i
        );
      },
      Clones: (t, e, s) => {
        const i = {
          mount() {
            (this.items = []), t.isInfinite() && (this.items = this.collect());
          },
          collect() {
            let s =
              0 < arguments.length && void 0 !== arguments[0]
                ? arguments[0]
                : [];
            const i = e.Html.slides,
              { slidesPerView: n, classes: r } = t.settings;
            if (0 !== i.length) {
              var o = n + (t.settings.peek ? 1 : 0) + Math.round(n / 2);
              const e = i.slice(0, o).reverse(),
                a = i.slice(-o);
              e.forEach((t) => {
                const e = t.cloneNode(!0);
                e.classList.add(r.slide.clone), s.push(e);
              }),
                a.forEach((t) => {
                  const e = t.cloneNode(!0);
                  e.classList.add(r.slide.clone), s.unshift(e);
                });
            }
            return s;
          },
          append() {
            const t = this.items,
              { train: s, slides: i } = e.Html;
            var n = Math.floor(t.length / 2);
            const r = t.slice(0, n).reverse(),
              o = t.slice(-n).reverse(),
              a = e.Sizes.slideWidth + "px";
            o.forEach((t) => s.appendChild(t)),
              r.forEach((t) => s.insertBefore(t, i[0])),
              t.forEach((t) => {
                (t.tabIndex = -1),
                  (t.style.width = a),
                  t.setAttribute("aria-hidden", "true"),
                  this.disableFocus(t);
              });
          },
          remove() {
            this.items.forEach((t) => {
              try {
                e.Html.train.removeChild(t);
              } catch (e) {
                console.warn(
                  `The node ${t} is not a child of the carousel train element`
                );
              }
            });
          },
          disableFocus(t) {
            t.querySelectorAll("a, button, input, [tabIndex]").forEach((t) => {
              t.tabIndex = -1;
            });
          },
        };
        return (
          Object.defineProperty(i, "grow", {
            get: () => (e.Sizes.slideWidth + e.Gaps.value) * i.items.length,
          }),
          s.on(G.UPDATE, () => {
            t.active && (i.remove(), i.mount(), i.append());
          }),
          s.on(G.BUILDING, () => {
            t.isInfinite() && t.active && i.append();
          }),
          s.on([G.DESTROY, G.DEACTIVATE], () => i.remove()),
          i
        );
      },
      Breakpoints: (e, s, i) => {
        const n = new t(),
          r = e.settings,
          o = r.breakpoints;
        let a = { ...r };
        const l = {
          match(t) {
            try {
              var e = t
                .sort((t, e) => (t.order > e.order ? -1 : 1))
                .find(
                  (t) => (
                    (t = t.mediaQuery), window.matchMedia(`(${t})`).matches
                  )
                );
              if (
                null != e &&
                e.settings &&
                0 !== Object.keys(e.settings).length
              )
                return e.settings;
            } catch (t) {
              Y("breakpoints: " + t);
            }
            return a;
          },
        };
        return (
          Object.assign(r, l.match(o)),
          n.on(
            "resize",
            window,
            et(() => {
              e.settings = q(r, l.match(o));
            }, 100)
          ),
          i.on(G.UPDATE, () => {
            a = { ...r };
          }),
          i.on(G.DESTROY, () => {
            n.off("resize", window);
          }),
          l
        );
      },
      Responsive: (e, s, i) => {
        const n = new t(),
          r = {
            mount() {
              this.bind();
            },
            onResize() {
              i.emit(G.RESIZE);
            },
            bind() {
              n.on("resize", window, et(this.onResize, 100));
            },
            unbind() {
              n.off("resize", window);
            },
          };
        return (
          i.on(G.DESTROY, () => {
            r.unbind(), n.destroy();
          }),
          r
        );
      },
      Build: (t, e, s) => {
        const i = {
          mount() {
            s.emit(G.BUILDING), this.activeClass(), s.emit(G.BUILT);
          },
          activeClass() {
            const s = t.settings.classes,
              i = e.Html.slides,
              n = i[t.index];
            n &&
              i.forEach((t) => {
                t === n
                  ? t.classList.add(s.slide.active)
                  : t.classList.remove(s.slide.active);
              });
          },
          removeClasses() {
            const s = t.settings.classes.slide;
            e.Html.slides.forEach((t) => t.classList.remove(s.active));
          },
        };
        return (
          s.on([G.DESTROY, G.UPDATE], () => {
            i.removeClasses();
          }),
          s.on([G.RESIZE, G.UPDATE], () => {
            i.mount();
          }),
          s.on(G.MOVED, () => {
            i.activeClass();
          }),
          i
        );
      },
      Run: (t, e, s) => {
        const i = {
          mount() {
            this.OFFSET = !1;
          },
          go(i) {
            t.disabled ||
              (t.disable(),
              (this.DIRECTION = i),
              this.calculate(),
              s.emit(G.RUN, this.DIRECTION),
              e.Transition.after(() => {
                this.isOffset() && (this.OFFSET = !1), t.enable();
              }));
          },
          calculateForwardIndex(e) {
            var s = t.index;
            return t.isInfinite() ? s + e : s + (e - (s % e));
          },
          normalizeForwardIndex(t) {
            var e = i.length;
            return t <= e ? t : i.isBound() ? e : t - (e + 1);
          },
          calculateBackwardIndex(e) {
            var s = t.index;
            return t.isInfinite() ? s - e : (Math.ceil(s / e) - 1) * e;
          },
          normalizeBackwardIndex(t) {
            var e = i.length;
            return 0 <= t ? t : i.isBound() ? 0 : t + (e + 1);
          },
          calculate() {
            const { direction: e, length: s } = this;
            var i = t.settings.slidesToScroll;
            if (">" === e) {
              var n = this.calculateForwardIndex(i);
              return (
                s < n && (this.OFFSET = !0),
                void (t.index = this.normalizeForwardIndex(n))
              );
            }
            if ("<" === e) {
              var r = this.calculateBackwardIndex(i);
              return (
                r < 0 && (this.OFFSET = !0),
                void (t.index = this.normalizeBackwardIndex(r))
              );
            }
            e.includes("=")
              ? ((r = parseInt(e.substr(1), 10)), (t.index = r || 0))
              : Y(`Invalid direction: "${e}". Use '>', '<' or '={index}'`);
          },
          isStart: () => t.index <= 0,
          isEnd() {
            return t.index >= this.length;
          },
          isOffset() {
            var t =
              0 < arguments.length && void 0 !== arguments[0]
                ? arguments[0]
                : void 0;
            return t ? !!this.OFFSET && this.direction === t : this.OFFSET;
          },
          isBound: () => !t.isInfinite(),
        };
        return (
          Object.defineProperty(i, "direction", {
            get() {
              return this.DIRECTION;
            },
            set(t) {
              this.direction = t;
            },
          }),
          Object.defineProperty(i, "length", {
            get() {
              var s = t.settings,
                i = e.Html.slides.length;
              return this.isBound()
                ? Math.max(0, i - 1 - (parseInt(s.slidesPerView, 10) - 1))
                : i - 1;
            },
          }),
          Object.defineProperty(i, "offset", {
            get() {
              return this.OFFSET;
            },
          }),
          i
        );
      },
      Controls: (e, n, r) => {
        const o = new t(),
          a = st(),
          l = {
            mount() {
              (this.ARROW_PREV = n.Html.root.querySelectorAll(nt)),
                (this.ARROW_NEXT = n.Html.root.querySelectorAll(rt)),
                (this.CONTROLS = [this.ARROW_PREV, this.ARROW_NEXT]),
                this.addBindings();
            },
            setArrowState() {
              this.resetArrowState(this.ARROW_PREV, this.ARROW_NEXT),
                e.isInfinite() ||
                  (n.Run.isStart() && this.disableArrow(this.ARROW_PREV),
                  n.Run.isEnd() && this.disableArrow(this.ARROW_NEXT));
            },
            resetArrowState() {
              for (
                var t = arguments.length, e = new Array(t), s = 0;
                s < t;
                s++
              )
                e[s] = arguments[s];
              e.forEach((t) => {
                t.forEach((t) => {
                  t.disabled = !1;
                });
              });
            },
            disableArrow() {
              for (
                var t = arguments.length, e = new Array(t), s = 0;
                s < t;
                s++
              )
                e[s] = arguments[s];
              e.forEach((t) => {
                t.forEach((t) => {
                  t.disabled = !0;
                });
              });
            },
            addBindings() {
              this.CONTROLS.forEach((t) => {
                this.bind(t);
              });
            },
            removeBindings() {
              this.CONTROLS.forEach((t) => {
                this.unbind(t);
              });
            },
            bind(t) {
              t.forEach((t) => {
                o.on([i_CLICK, s_START], t, this.handleClick, a);
              });
            },
            unbind(t) {
              t.forEach((t) => {
                o.off([i_CLICK, s_START], t, a);
              });
            },
            handleClick(t) {
              a || t.type !== s_START || t.preventDefault(),
                (t = t.currentTarget.getAttribute(it)),
                n.Run.go(t);
            },
          };
        return (
          Object.defineProperty(l, "items", { get: () => l.CONTROLS }),
          r.on([G.MOUNTED, G.RUN, G.RESIZE, G.UPDATE], () => l.setArrowState()),
          r.on(G.DESTROY, () => {
            l.removeBindings(), o.destroy();
          }),
          l
        );
      },
      Touch: (e, n, r) => {
        const o = st(),
          a = new t();
        let l = 0,
          d = 0,
          h = 0,
          c = !1;
        const u = {
          mount() {
            this.bindSwipeStart();
          },
          start(t) {
            c ||
              e.disabled ||
              (this.disable(),
              (t = this.touches(t)),
              (l = null),
              (d = parseInt(t.pageX, 10)),
              (h = parseInt(t.pageY, 10)),
              this.bindSwipeMove(),
              this.bindSwipeEnd());
          },
          move(t) {
            var s, i, r, o, a, c;
            return (
              e.disabled ||
                (({ touchAngle: s, touchRatio: i, classes: r } = e.settings),
                (a = this.touches(t)),
                (o = parseInt(a.pageX, 10) - d),
                (c = parseInt(a.pageY, 10) - h),
                (a = Math.abs(o << 2)),
                (c = Math.abs(c << 2)),
                (a = Math.sqrt(a + c)),
                (c = Math.sqrt(c)),
                (l = Math.asin(c / a)),
                (180 * l) / Math.PI < s &&
                  (t.stopPropagation(),
                  n.Move.make(o * parseFloat(i)),
                  n.Html.root.classList.add(r.dragging))),
              !1
            );
          },
          end(t) {
            var s, i, r, o;
            e.disabled ||
              (({ touchAngle: s, classes: i } = e.settings),
              (o = this.touches(t)),
              (r = this.threshold(t)),
              (t = o.pageX - d),
              (o = (180 * l) / Math.PI),
              this.enable(),
              r < t && o < s
                ? n.Run.go("<")
                : t < -r && o < s
                ? n.Run.go(">")
                : n.Move.make(),
              n.Html.root.classList.remove(i.dragging),
              this.unbindSwipeMove(),
              this.unbindSwipeEnd());
          },
          bindSwipeStart() {
            var { swipeThreshold: t, dragThreshold: r } = e.settings;
            t && a.on(s_START, n.Html.train, (t) => this.start(t), o),
              r && a.on(i_DOWN, n.Html.train, (t) => this.start(t), o);
          },
          unbindSwipeStart() {
            a.off(s_START, n.Html.train, o), a.off(i_DOWN, n.Html.train, o);
          },
          bindSwipeMove() {
            a.on(
              at,
              n.Html.train,
              et((t) => this.move(t), 10),
              o
            );
          },
          unbindSwipeMove() {
            a.off(at, n.Html.train, o);
          },
          bindSwipeEnd() {
            a.on(lt, n.Html.train, (t) => this.end(t));
          },
          unbindSwipeEnd() {
            a.off(lt, n.Html.train);
          },
          touches: (t) =>
            -1 < dt.indexOf(t.type) ? t : t.touches[0] || t.changedTouches[0],
          threshold(t) {
            var s = e.settings;
            return -1 < dt.indexOf(t.type) ? s.dragThreshold : s.swipeThreshold;
          },
          enable() {
            return (c = !1), n.Transition.enable(), this;
          },
          disable() {
            return (c = !0), n.Transition.disable(), this;
          },
        };
        return (
          r.on(G.BUILT, () => {
            n.Html.root.classList.add(e.settings.classes.touch);
          }),
          r.on(G.DESTROY, () => {
            u.unbindSwipeStart(),
              u.unbindSwipeMove(),
              u.unbindSwipeEnd(),
              a.destroy();
          }),
          u
        );
      },
      Keys: (e, s, i) => {
        const r = new t(),
          o = {
            mount() {
              this.bind();
            },
            bind() {
              r.on("keyup", document, this.onKeyPress);
            },
            unbind() {
              r.off("keyup", document);
            },
            onKeyPress(t) {
              if (t.keyCode === n.TAB) {
                const { root: n, train: r } = s.Html;
                var e, i;
                r.contains(document.activeElement) &&
                  ((e = n.getBoundingClientRect()),
                  ({ left: i, right: t } =
                    document.activeElement.getBoundingClientRect()),
                  i < e.left && s.Run.go("<"),
                  t > e.right && s.Run.go(">"));
              }
            },
          };
        return (
          i.on(G.UPDATE, () => {
            o.unbind(), o.mount();
          }),
          i.on(G.DESTROY, () => {
            o.unbind(), r.destroy();
          }),
          o
        );
      },
      Clamp: (t, e, s) => {
        const i = {
          onResize() {
            t.isInfinite() ||
              (t.index > e.Run.length && (t.index = e.Run.length));
          },
        };
        return s.on(G.RESIZE, () => i.onResize()), i;
      },
    };
  class ct extends class {
    constructor(t) {
      var s =
        1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : {};
      (this.addons = {}),
        (this.selector = t),
        (this.disabled = !1),
        (this.active = !0),
        (this.settings = { ...$, ...s }),
        (this.index = this.settings.startAt),
        (this.eventHandler = new e());
    }
    mount() {
      var t =
        0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : {};
      return (
        "object" == typeof t
          ? (this.addons = ((t, e, s) => {
              const i = {};
              return (
                Object.entries(e).forEach((e) => {
                  let [n, r] = e;
                  "function" == typeof r
                    ? (i[n] = r(t, i, s))
                    : Y("addon must be a function");
                }),
                Object.values(i).forEach((t) => {
                  "function" == typeof t.mount && t.mount();
                }),
                i
              );
            })(this, t, this.eventHandler))
          : Y("must provide an object on `mount()`"),
        this.eventHandler.emit(G.MOUNTED),
        this
      );
    }
    isInfinite() {
      return this.settings.infinite;
    }
    update() {
      var t =
        0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : {};
      return (
        (this.settings = q($, t)),
        t.startAt && (this.index = parseInt(t.startAt, 10)),
        this.eventHandler.emit(G.UPDATE),
        this
      );
    }
    on(t, e) {
      return this.eventHandler.on(t, e), this;
    }
    goTo(t) {
      return this.addons.Run.go(t), this;
    }
    disable() {
      return (this.disabled = !0), this;
    }
    enable() {
      return (this.disabled = !1), this;
    }
    activate() {
      return (
        (this.active = !0),
        this.enable(),
        this.eventHandler.emit(G.UPDATE),
        this
      );
    }
    deactivate() {
      return (
        (this.active = !1),
        this.disable(),
        this.eventHandler.emit(G.DEACTIVATE),
        this
      );
    }
    destroy() {
      return this.eventHandler.emit(G.DESTROY), this;
    }
  } {
    mount() {
      var t =
        0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : {};
      return super.mount({ ...ht, ...t });
    }
  }
  const ut = {
      infinite: !0,
      peek: 0,
      slideGap: 8,
      slidesPerView: 1,
      slidesToScroll: 1,
    },
    mt = class extends B {
      constructor(t) {
        super(t), (this.settings = { ...ut, breakpoints: [] });
      }
      update() {
        var t =
          0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : {};
        return this.carousel.update({ ...this.settings, ...t }), this;
      }
      mountWithCarousel() {
        let t =
          0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : {};
        return (
          this.mount(),
          (this.carousel = new ct(`#${this.id} .cl-carousel`, {
            ...this.settings,
            ...t,
          }).mount()),
          this.on("open", (e) => {
            (e = ((null == (e = e.element) ? void 0 : e.dataset) || 0).index),
              this.carousel.update({ ...this.settings, ...t, startAt: e });
          }),
          this
        );
      }
      destroy() {
        return (
          this.carousel.destroy(),
          this.binder.destroy(),
          this.tabTrap.destroy(),
          this
        );
      }
    },
    ft = [...document.querySelectorAll(".csol-lightbox")];
  ft.forEach((t) => {
    if (!t.parentElement.id)
      return void console.error("Lightbox detected but missing an ID.");
    ((t) => ft.filter((e) => e.id === t.parentElement.id).length > 1)(t) &&
      console.error(
        `Multiple lightboxes with the same ID (${t.id}) detected, so only the first lightbox with this ID will be shown when modal buttons associated with this ID are clicked. Please give each lightbox a unique ID.`
      );
    const { id: e } = t.parentElement;
    e &&
      (document.body.appendChild(t.parentElement),
      new mt(e).mountWithCarousel());
  });
})();
